.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ASYNC_start_job 3"
.TH ASYNC_start_job 3 "2015-12-05" "1.1.0-dev" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ASYNC_init, ASYNC_cleanup, ASYNC_init_thread, ASYNC_cleanup_thread,
ASYNC_start_job, ASYNC_pause_job, ASYNC_in_job, ASYNC_get_wait_fd,
ASYNC_get_current_job, ASYNC_wake, ASYNC_clear_wake, ASYNC_block_pause,
ASYNC_unblock_pause \- asynchronous job management functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/async.h>
\&
\& int ASYNC_init(int init_thread, size_t max_size, size_t init_size);
\& void ASYNC_cleanup(int cleanupthread);
\&
\& int ASYNC_init_thread(size_t max_size, size_t init_size);
\& void ASYNC_cleanup_thread(void);
\&
\& int ASYNC_start_job(ASYNC_JOB **job, int *ret, int (*func)(void *),
\&                     void *args, size_t size);
\& int ASYNC_pause_job(void);
\&
\& int ASYNC_get_wait_fd(ASYNC_JOB *job);
\& ASYNC_JOB *ASYNC_get_current_job(void);
\& void ASYNC_wake(ASYNC_JOB *job);
\& void ASYNC_clear_wake(ASYNC_JOB *job);
\& void ASYNC_block_pause(void);
\& void ASYNC_unblock_pause(void);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
OpenSSL implements asynchronous capabilities through an \s-1ASYNC_JOB.\s0 This
represents code that can be started and executes until some event occurs. At
that point the code can be paused and control returns to user code until some
subsequent event indicates that the job can be resumed.
.PP
The creation of an \s-1ASYNC_JOB\s0 is a relatively expensive operation. Therefore, for
efficiency reasons, jobs can be created up front and reused many times. They are
held in a pool until they are needed, at which point they are removed from the
pool, used, and then returned to the pool when the job completes. Before using
any of the asynchronous job functions, user code should first call
\&\fIASYNC_init()\fR. If the user application is multi-threaded, then
\&\fIASYNC_init_thread()\fR should be called for each thread that will initiate
asynchronous jobs. If the \fBinit_thread\fR parameter to \fIASYNC_init()\fR is non-zero
then ASYNC_init_thread is automatically called for the current thread. Before
user code exits it should free up resources for each thread that was initialised
using \fIASYNC_cleanup_thread()\fR. No asynchronous jobs must be outstanding for the thread
when \fIASYNC_cleanup_thread()\fR is called. Failing to ensure this will result in memory
leaks. Additionally an application should call \fIASYNC_cleanup()\fR when all
asynchronous work is complete across all threads. If \fBcleanupthread\fR is
non-zero then \fIASYNC_cleanup_thread()\fR is automatically called for the current
thread.
.PP
The \fBmax_size\fR argument limits the number of ASYNC_JOBs that will be held in
the pool. If \fBmax_size\fR is set to 0 then no upper limit is set. When an
\&\s-1ASYNC_JOB\s0 is needed but there are none available in the pool already then one
will be automatically created, as long as the total of ASYNC_JOBs managed by the
pool does not exceed \fBmax_size\fR. When the pool is first initialised
\&\fBinit_size\fR ASYNC_JOBs will be created immediately. If \fIASYNC_init_thread()\fR is
not called before the pool is first used then it will be called automatically
with a \fBmax_size\fR of 0 (no upper limit) and an \fBinit_size\fR of 0 (no ASYNC_JOBs
created up front). If a pool is created in this way it must still be cleaned up
with an explicit call to \fIASYNC_cleanup_thread()\fR.
.PP
An asynchronous job is started by calling the \fIASYNC_start_job()\fR function.
Initially \fB*job\fR should be \s-1NULL. \s0\fBret\fR should point to a location where the
return value of the asynchronous function should be stored on completion of the
job. \fBfunc\fR represents the function that should be started asynchronously. The
data pointed to by \fBargs\fR and of size \fBsize\fR will be copied and then passed as
an argument to \fBfunc\fR when the job starts. ASYNC_start_job will return one of
the following values:
.IP "\fB\s-1ASYNC_ERR\s0\fR" 4
.IX Item "ASYNC_ERR"
An error occurred trying to start the job. Check the OpenSSL error queue (e.g.
see \fIERR_print_errors\fR\|(3)) for more details.
.IP "\fB\s-1ASYNC_NO_JOBS\s0\fR" 4
.IX Item "ASYNC_NO_JOBS"
There are no jobs currently available in the pool. This call can be retried
again at a later time.
.IP "\fB\s-1ASYNC_PAUSE\s0\fR" 4
.IX Item "ASYNC_PAUSE"
The job was successfully started but was \*(L"paused\*(R" before it completed (see
\&\fIASYNC_pause_job()\fR below). A handle to the job is placed in \fB*job\fR. Other work
can be performed (if desired) and the job restarted at a later time. To restart
a job call \fIASYNC_start_job()\fR again passing the job handle in \fB*job\fR. The
\&\fBfunc\fR, \fBargs\fR and \fBsize\fR parameters will be ignored when restarting a job.
When restarting a job \fIASYNC_start_job()\fR \fBmust\fR be called from the same thread
that the job was originally started from.
.IP "\fB\s-1ASYNC_FINISH\s0\fR" 4
.IX Item "ASYNC_FINISH"
The job completed. \fB*job\fR will be \s-1NULL\s0 and the return value from \fBfunc\fR will
be placed in \fB*ret\fR.
.PP
At any one time there can be a maximum of one job actively running per thread
(you can have many that are paused). \fIASYNC_get_current_job()\fR can be used to get
a pointer to the currently executing \s-1ASYNC_JOB.\s0 If no job is currently executing
then this will return \s-1NULL.\s0
.PP
If executing within the context of a job (i.e. having been called directly or
indirectly by the function \*(L"func\*(R" passed as an argument to \fIASYNC_start_job()\fR)
then \fIASYNC_pause_job()\fR will immediately return control to the calling
application with \s-1ASYNC_PAUSE\s0 returned from the \fIASYNC_start_job()\fR call. A
subsequent call to ASYNC_start_job passing in the relevant \s-1ASYNC_JOB\s0 in the
\&\fB*job\fR parameter will resume execution from the \fIASYNC_pause_job()\fR call. If
\&\fIASYNC_pause_job()\fR is called whilst not within the context of a job then no
action is taken and \fIASYNC_pause_job()\fR returns immediately.
.PP
Every \s-1ASYNC_JOB\s0 has a \*(L"wait\*(R" file descriptor associated with it. Calling
\&\fIASYNC_get_wait_fd()\fR and passing in a pointer to an \s-1ASYNC_JOB\s0 in the \fBjob\fR
parameter will return the wait file descriptor associated with that job. This
file descriptor can be used to signal that the job should be resumed.
Applications can wait for the file descriptor to be ready for \*(L"read\*(R" using a
system function call such as select or poll (being ready for \*(L"read\*(R" indicates
that the job should be resumed). Applications can signal that a job is ready to
resume using \fIASYNC_wake()\fR or clear an existing signal using \fIASYNC_clear_wake()\fR.
.PP
An example of typical usage might be an async capable engine. User code would
initiate cryptographic operations. The engine would initiate those operations
asynchronously and then call \fIASYNC_pause_job()\fR to return control to the user
code. The user code can then perform other tasks or wait for the job to be ready
by calling \*(L"select\*(R" or other similar function on the wait file descriptor. The
engine can signal to the user code that the job should be resumed using
\&\fIASYNC_wake()\fR. Once resumed the engine would clear the wake signal by calling
\&\fIASYNC_clear_wake()\fR.
.PP
The \fIASYNC_block_pause()\fR function will prevent the currently active job from
pausing. The block will remain in place until a subsequent call to
\&\fIASYNC_unblock_pause()\fR. These functions can be nested, e.g. if you call
\&\fIASYNC_block_pause()\fR twice then you must call \fIASYNC_unblock_pause()\fR twice in
order to reenable pausing. If these functions are called while there is no
currently active job then they have no effect. This functionality can be useful
to avoid deadlock scenarios. For example during the execution of an \s-1ASYNC_JOB\s0 an
application aquires a lock. It then calls some cryptographic function which
invokes \fIASYNC_pause_job()\fR. This returns control back to the code that created
the \s-1ASYNC_JOB.\s0 If that code then attempts to aquire the same lock before
resuming the original job then a deadlock can occur. By calling
\&\fIASYNC_block_pause()\fR immediately after aquiring the lock and
\&\fIASYNC_unblock_pause()\fR immediately before releasing it then this situation cannot
occur.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
ASYNC_init and ASYNC_init_thread return 1 on success or 0 otherwise.
.PP
ASYNC_start_job returns one of \s-1ASYNC_ERR, ASYNC_NO_JOBS, ASYNC_PAUSE\s0 or
\&\s-1ASYNC_FINISH\s0 as described above.
.PP
ASYNC_pause_job returns 0 if an error occured or 1 on success. If called when
not within the context of an \s-1ASYNC_JOB\s0 then this is counted as success so 1 is
returned.
.PP
ASYNC_get_wait_fd returns the \*(L"wait\*(R" file descriptor associated with the
\&\s-1ASYNC_JOB\s0 provided as an argument.
.PP
ASYNC_get_current_job returns a pointer to the currently executing \s-1ASYNC_JOB\s0 or
\&\s-1NULL\s0 if not within the context of a job.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
The following example demonstrates how to use most of the core async APIs:
.PP
.Vb 2
\& #include <stdio.h>
\& #include <openssl/async.h>
\&
\& int jobfunc(void *arg)
\& {
\&     ASYNC_JOB *currjob;
\&     unsigned char *msg;
\&
\&     currjob = ASYNC_get_current_job();
\&     if (currjob != NULL) {
\&         printf("Executing within a job\en");
\&     } else {
\&         printf("Not executing within a job \- should not happen\en");
\&         return 0;
\&     }
\&
\&     msg = (unsigned char *)arg;
\&     printf("Passed in message is: %s\en", msg);
\&
\&     /*
\&      * Normally some external event would cause this to happen at some
\&      * later point \- but we do it here for demo purposes, i.e.
\&      * immediately signalling that the job is ready to be woken up after
\&      * we return to main via ASYNC_pause_job().
\&      */
\&     ASYNC_wake(currjob);
\&
\&     /* Return control back to main */
\&     ASYNC_pause_job();
\&
\&     /* Clear the wake signal */
\&     ASYNC_clear_wake(currjob);
\&
\&     printf ("Resumed the job after a pause\en");
\&
\&     return 1;
\& }
\&
\& int main(void)
\& {
\&     ASYNC_JOB *job = NULL;
\&     int ret, waitfd;
\&     fd_set waitfdset;
\&     unsigned char msg[13] = "Hello world!";
\&
\&     /*
\&      * We\*(Aqre only expecting 1 job to be used here so we\*(Aqre only creating
\&      * a pool of 1
\&      */
\&     if (!ASYNC_init(1, 1, 1)) {
\&         printf("Error creating pool\en");
\&         goto end;
\&     }
\&
\&     printf("Starting...\en");
\&
\&     for (;;) {
\&         switch(ASYNC_start_job(&job, &ret, jobfunc, msg, sizeof(msg))) {
\&         case ASYNC_ERR:
\&         case ASYNC_NO_JOBS:
\&                 printf("An error occurred\en");
\&                 goto end;
\&         case ASYNC_PAUSE:
\&                 printf("Job was paused\en");
\&                 break;
\&         case ASYNC_FINISH:
\&                 printf("Job finished with return value %d\en", ret);
\&                 goto end;
\&         }
\&
\&         /* Wait for the job to be woken */
\&         printf("Waiting for the job to be woken up\en");
\&         waitfd = ASYNC_get_wait_fd(job);
\&         FD_ZERO(&waitfdset);
\&         FD_SET(waitfd, &waitfdset);
\&         select(waitfd + 1, &waitfdset, NULL, NULL, NULL);
\&     }
\&
\& end:
\&     printf("Finishing\en");
\&     ASYNC_cleanup(1);
\&
\&     return 0;
\& }
.Ve
.PP
The expected output from executing the above example program is:
.PP
.Vb 8
\& Starting...
\& Executing within a job
\& Passed in message is: Hello world!
\& Job was paused
\& Waiting for the job to be woken up
\& Resumed the job after a pause
\& Job finished with return value 1
\& Finishing
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIcrypto\fR\|(3), \fIERR_print_errors\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
ASYNC_init, ASYNC_init_thread, ASYNC_cleanup, ASYNC_cleanup_thread,
ASYNC_start_job, ASYNC_pause_job, ASYNC_get_wait_fd, ASYNC_get_current_job,
ASYNC_wake, ASYNC_clear_wake were first added to OpenSSL 1.1.0.
