.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CRYPTO_secure_malloc 3"
.TH CRYPTO_secure_malloc 3 "2015-12-05" "1.1.0-dev" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CRYPTO_secure_malloc_init, CRYPTO_secure_malloc_done, OPENSSL_secure_malloc, OPENSSL_secure_free, OPENSSL_secure_allocated \- use secure heap storage
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/crypto.h>
\&
\& int CRYPTO_secure_malloc_init(size_t size, int minsize);
\&
\& int CRYPTO_secure_malloc_initialized();
\&
\& void CRYPTO_secure_malloc_done();
\&
\& void *OPENSSL_secure_malloc(int num);
\&
\& void OPENSSL_secure_free(void* ptr);
\&
\& int OPENSSL_secure_allocated(const void* ptr);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In order to help protect applications (particularly long-running servers)
from pointer overruns or underruns that could return arbitrary data from
the program's dynamic memory area, where keys and other sensitive
information might be stored, OpenSSL supports the concept of a \*(L"secure heap.\*(R"
The level and type of security guarantees depend on the operating system.
It is a good idea to review the code and see if it addresses your
threat model and concerns.
.PP
If a secure heap is used, then private key \fB\s-1BIGNUM\s0\fR values are stored there.
This protects long-term storage of private keys, but will not necessarily
put all intermediate values and computations there.
.PP
\&\fBCRYPTO_secure_malloc_init\fR creates the secure heap, with the specified
\&\f(CW\*(C`size\*(C'\fR in bytes. The \f(CW\*(C`minsize\*(C'\fR parameter is the minimum size to
allocate from the heap. Both \f(CW\*(C`size\*(C'\fR and \f(CW\*(C`minsize\*(C'\fR must be a power
of two.  It is an error to call this after any \fBOPENSSL_secure_malloc\fR
calls have been made.
.PP
\&\fBCRYPTO_secure_malloc_initialized\fR indicates whether or not the secure
heap as been initialized and is available.
.PP
\&\fBCRYPTO_secure_malloc_done\fR releases the heap and makes the memory unavailable
to the process. It can take noticeably long to complete.
.PP
\&\fBOPENSSL_secure_malloc\fR allocates \f(CW\*(C`num\*(C'\fR bytes from the heap.
If \fBCRYPTO_secure_malloc_init\fR is not called, this is equivalent to
calling \fBOPENSSL_malloc\fR.
.PP
\&\fBOPENSSL_secure_free\fR releases the memory at \f(CW\*(C`ptr\*(C'\fR back to the heap.
It must be called with a value previously obtained from
\&\fBOPENSSL_secure_malloc\fR.
If \fBCRYPTO_secure_malloc_init\fR is not called, this is equivalent to
calling \fBOPENSSL_free\fR.
.PP
\&\fBOPENSSL_secure_allocated\fR tells whether or not a pointer is within
the secure heap.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBCRYPTO_secure_malloc_init\fR returns 0 on failure, 1 if successful,
and 2 if successful but the heap could not be protected by memory
mapping.
.PP
\&\fBCRYPTO_secure_malloc_initialized\fR returns 1 if the secure heap is
available (that is, if \fBCRYPTO_secure_malloc_init\fR has been called,
but \fBCRYPTO_secure_malloc_done\fR has not) or 0 if not.
.PP
\&\fBOPENSSL_secure_malloc\fR returns a pointer into the secure heap of
the requested size, or \f(CW\*(C`NULL\*(C'\fR if memory could not be allocated.
.PP
\&\fBCRYPTO_secure_allocated\fR returns 1 if the pointer is in the
the secure heap, or 0 if not.
.PP
\&\fBCRYPTO_secure_malloc_done\fR and \fBOPENSSL_secure_free\fR
return no values.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIBN_new\fR\|(3),
\&\fIbn_internal\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
These functions were contributed to the OpenSSL project by
Akamai Technologies in April, 2014.
